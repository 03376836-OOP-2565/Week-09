# 9.1 Constructor 

- Constructors เป็น method ที่มีชื่อเดียวกับคลาส

- ถูกเรียกใช้ทันทีเมื่อสร้าง instance ใหม่

- เป็นที่ที่เหมาะสำหรับการ initial ค่า state ต่างๆ ให้แก่ instance

- ถ้าต้องการให้สร้าง instance จากภายนอกคลาส ให้กำหนด modifier เป็น public

- constructor ไม่สามารถส่งค่ากลับ (ไม่ต้องใส่ชนิด return แม้กระทั่ง void)

## 9.1.1  ใช้ Instance constructors

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล
``` cs
using System.Drawing;

namespace ConstructorExample
{
    class Cat
    { 
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }

        // Constructor
        public Cat() 
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat();
            Console.WriteLine($"Cat birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat color = {c1.CatColor.Name}");
        }
    }
}
```
![image](https://github.com/suwithirunrat/Week-09/assets/116150760/46fec0f3-1511-46c7-8400-5408336a3ae0)

## 9.1.2 Constructors with Parameters

- Constructors มีฐานะเป็น method สามารถรับ parameters ได้เช่นเดียวกับ method ทั่วไป ใช้รูปแบบของพารามิเตอร์เช่นเดียวกับ method อื่น ๆ และสามารถทำ overloaded ได้    

- ในขณะที่สร้าง instance คอมไพเลอร์จะเลือก constructor ที่มี signature ตรงกับ constructor ตัวหนึ่งขึ้นมาทำงาน

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล
```cs
using System.Drawing;
namespace ConstructorExample
{
    class Cat
    { 
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }
        
        // Default constructor
        public Cat() 
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }
        // Parameterized constructor
        public Cat(Color catColor)
        {
             BirthTime = DateTime.Now;
             CatColor = catColor;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat();
            Console.WriteLine($"Cat birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat color = {c1.CatColor.Name}");

            // Challenge:  use Parameterized constructor

            var ___ = new Cat(_______);
            Console.WriteLine($"__________________");
            Console.WriteLine($"__________________");
        }
    }
}
```
![image](https://github.com/suwithirunrat/Week-09/assets/116150760/a6dee1a8-bd79-48ea-87ab-164a93514fe6)

## 9.1.3 การใช้ this() เพื่อเรียก constructor

โดยปกติ เราไม่สามารถเรียกใช้งาน constructor ได้โดยตรง 

เมื่อผู้ใช้สร้าง instance โดยการป้อน parameters ตามที่ต้องการ compiler จะเเลือก overloaded constructor ที่มีรายการ constructor ตรงกันขึ้นมาทำงาน
ในจังหวะนี้เราสามารถเรียก constructor ตัวอื่นขึ้นมาทำงานโดยใช้ this(<parameters list>)

การเรียก constructor ตัวอื่น สามารถเรียกต่อกันเป็นลูกโซ่ได้ตามต้องการ


รันโปรแกรมตามตัวอย่างนี้และบันทึกผล

```cs
using System.Drawing;
namespace ConstructorExample
{
    class Cat
    {
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }
        public string?  Name { get; set; }

        // Default constructor
        public Cat()
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }
        // Parameterized constructor
        public Cat(Color catColor) : this() // เรียก default constructor
        {
            CatColor = catColor;
        }
        public Cat(string name, Color color) : this(color) // เรียก overloaded constructor 'public Cat(Color catColor)'
        {
            Name = name;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat("Jumbo", Color.AntiqueWhite);
            Console.WriteLine($"Cat birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat color = {c1.CatColor.Name}");
            Console.WriteLine($"Cat Name = {c1.Name}");
        }
    }
}
```
![image](https://github.com/suwithirunrat/Week-09/assets/116150760/63df3cc7-0de7-4490-b38f-24e61d5dd0d0)

## 9.1.4 Static constructor

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล

```cs
using System.Drawing;
namespace ConstructorExample
{
    class Cat
    {
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }

        public static readonly DateTime globalStartTime;

        // Default constructor
        public Cat()
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }

        // Static constructor
        static Cat()  
        {
            globalStartTime = DateTime.Now;
        }


        // Parameterized constructor
        public Cat(Color catColor)  : this()
        {
            CatColor = catColor;
        }
        public Cat(Color catColor, DateTime born) : this(catColor)
        {
            BirthTime = born;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat(Color.AntiqueWhite);
            Console.WriteLine($"Cat 1 birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat 1 color = {c1.CatColor.Name}");
            Console.WriteLine($"Cat 1 age = {Cat.globalStartTime - c1.BirthTime}"); 

            var c2 = new Cat(Color.Brown, new DateTime(2023, 04, 13));
            Console.WriteLine($"Cat 2 birth time = {c2.BirthTime}");
            Console.WriteLine($"Cat 2 color = {c2.CatColor.Name}");
            Console.WriteLine($"Cat 1 age = {Cat.globalStartTime - c2.BirthTime}");

            var c3 = new Cat() { CatColor = Color.Orange, BirthTime = new DateTime(2022, 05, 01) };
            Console.WriteLine($"Cat 3 birth time = {c3.BirthTime}");
            Console.WriteLine($"Cat 3 color = {c3.CatColor.Name}");
            Console.WriteLine($"Cat 1 age = { Cat.globalStartTime - c3.BirthTime}");
        }
    }
}
```
![image](https://github.com/suwithirunrat/Week-09/assets/116150760/70d0b12c-2006-4d9e-9528-dc562b041e3f)

## 9.1.5 Object initializer

ในบางกรณี เราไม่สามารถสร้าง constructor หลายๆ ตัวเพื่อที่จะรับค่า parameters ที่แตกต่างกันเข้าสู่ object

ในภาษา C# มีวิธีการกำหนดค่าเริ่มต้นให้ properties ผ่าน Object initializer

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล

```cs
using System.Drawing;

namespace ConstructorExample
{
    class Cat
    { 
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }
        public static int catID;
        public Cat() 
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
            catID++;
        }
        public Cat(Color catColor) :this()     
        {
            CatColor = catColor;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c3 = new Cat() { CatColor = Color.Orange, BirthTime = new DateTime(2023, 05, 01) };
            Console.WriteLine($"Cat 3 birth time = {c3.BirthTime}");
            Console.WriteLine($"Cat 3 color = {c3.CatColor.Name}");
        }
    }
}

```
![image](https://github.com/suwithirunrat/Week-09/assets/116150760/7a9d903f-8605-4bfb-89a6-881f43eecbad)

## คำถาม

1. ท่านคิดว่าวิธีการทำ constructor overloading แล้วเรียกต่อกันเป็นทอดๆ จะช่วยอำนวยความสะดวกอะไรในการเขียนโปรแกรมของท่าน
ช่วยให้โปรแกรมทำงานได้มีประสิทธิภาพมากขึ้นโดยสามารถรับค่าที่หลากหลายได้และไม่ error หากรับค่าเกินที่กำหนดแต่แลกมาด้วยความที่โปรแกรมอาจจะช้าเนื่องจากต้องรันโค้ดหลายบรรทัดมากขึ้น
2. เปรียบเทียบประโยชน์และข้อจำกัด ในการใช้ overloaded constructor และ Object initializer
    สามารถรองรับการป้อนค่าได้หลากหลาย ข้อจำกัด
โปรแกรมอาจจะทำงานได้ช้าลงหากมี overloaded constructor เป็นจำนวนมากเพราะจะทำให้โค้ดมีบรรทัดมากขึ้น
โค้ดยาวและอ่านยาก Object initializer ประโยชน์
ทำให้โค้ดสั้นลง อ่านง่าย
ลดความผิดพลาดในการกำหนด properties โดยจพมีการตรวจสอบความถูกต้องก่อนกำหนดค่า ข้อจำกัด
ต้องกำหนดค่าทุก property ตอนที่สร้าง
อาจสร้าง confusion ในกรณีที่มี property ที่มีชื่อซ้ำกันใน base class และ derived class หรือในกรณีที่มีการ inherit property จาก interface ที่มีชื่อซ้ำกัน
