# 9.1 Constructor 

- Constructors เป็น method ที่มีชื่อเดียวกับคลาส

- ถูกเรียกใช้ทันทีเมื่อสร้าง instance ใหม่

- เป็นที่ที่เหมาะสำหรับการ initial ค่า state ต่างๆ ให้แก่ instance

- ถ้าต้องการให้สร้าง instance จากภายนอกคลาส ให้กำหนด modifier เป็น public

- constructor ไม่สามารถส่งค่ากลับ (ไม่ต้องใส่ชนิด return แม้กระทั่ง void)

## 9.1.1  ใช้ Instance constructors

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล
``` cs
using System.Drawing;

namespace ConstructorExample
{
    class Cat
    { 
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }

        // Constructor
        public Cat() 
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat();
            Console.WriteLine($"Cat birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat color = {c1.CatColor.Name}");
        }
    }
}
```
![image](https://user-images.githubusercontent.com/115066329/236631064-d1ee94a1-fecd-4a99-ab34-ac51419f9420.png)


## 9.1.2 Constructors with Parameters

- Constructors มีฐานะเป็น method สามารถรับ parameters ได้เช่นเดียวกับ method ทั่วไป ใช้รูปแบบของพารามิเตอร์เช่นเดียวกับ method อื่น ๆ และสามารถทำ overloaded ได้    

- ในขณะที่สร้าง instance คอมไพเลอร์จะเลือก constructor ที่มี signature ตรงกับ constructor ตัวหนึ่งขึ้นมาทำงาน

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล
```cs
using System.Drawing;
namespace ConstructorExample
{
    class Cat
    { 
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }
        
        // Default constructor
        public Cat() 
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }
        // Parameterized constructor
        public Cat(Color catColor)
        {
             BirthTime = DateTime.Now;
             CatColor = catColor;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat();
            Console.WriteLine($"Cat birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat color = {c1.CatColor.Name}");

            // Challenge:  use Parameterized constructor

            var ___ = new Cat(_______);
            Console.WriteLine($"__________________");
            Console.WriteLine($"__________________");
        }
    }
}
```
![image](https://user-images.githubusercontent.com/115066329/236631162-c0f97679-4c7c-464b-ab71-0a8785a52fc0.png)


## 9.1.3 การใช้ this() เพื่อเรียก constructor

โดยปกติ เราไม่สามารถเรียกใช้งาน constructor ได้โดยตรง 

เมื่อผู้ใช้สร้าง instance โดยการป้อน parameters ตามที่ต้องการ compiler จะเเลือก overloaded constructor ที่มีรายการ constructor ตรงกันขึ้นมาทำงาน
ในจังหวะนี้เราสามารถเรียก constructor ตัวอื่นขึ้นมาทำงานโดยใช้ this(<parameters list>)

การเรียก constructor ตัวอื่น สามารถเรียกต่อกันเป็นลูกโซ่ได้ตามต้องการ


รันโปรแกรมตามตัวอย่างนี้และบันทึกผล

```cs
using System.Drawing;
namespace ConstructorExample
{
    class Cat
    {
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }
        public string?  Name { get; set; }

        // Default constructor
        public Cat()
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }
        // Parameterized constructor
        public Cat(Color catColor) : this() // เรียก default constructor
        {
            CatColor = catColor;
        }
        public Cat(string name, Color color) : this(color) // เรียก overloaded constructor 'public Cat(Color catColor)'
        {
            Name = name;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat("Jumbo", Color.AntiqueWhite);
            Console.WriteLine($"Cat birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat color = {c1.CatColor.Name}");
            Console.WriteLine($"Cat Name = {c1.Name}");
        }
    }
}
```
![image](https://user-images.githubusercontent.com/115066329/236631193-5d63ad38-4f39-4aca-b6e1-50b278841b85.png)

## 9.1.4 Static constructor

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล

```cs
using System.Drawing;
namespace ConstructorExample
{
    class Cat
    {
        // Properties
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }

        public static readonly DateTime globalStartTime;

        // Default constructor
        public Cat()
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
        }

        // Static constructor
        static Cat()  
        {
            globalStartTime = DateTime.Now;
        }


        // Parameterized constructor
        public Cat(Color catColor)  : this()
        {
            CatColor = catColor;
        }
        public Cat(Color catColor, DateTime born) : this(catColor)
        {
            BirthTime = born;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c1 = new Cat(Color.AntiqueWhite);
            Console.WriteLine($"Cat 1 birth time = {c1.BirthTime}");
            Console.WriteLine($"Cat 1 color = {c1.CatColor.Name}");
            Console.WriteLine($"Cat 1 age = {Cat.globalStartTime - c1.BirthTime}"); 

            var c2 = new Cat(Color.Brown, new DateTime(2023, 04, 13));
            Console.WriteLine($"Cat 2 birth time = {c2.BirthTime}");
            Console.WriteLine($"Cat 2 color = {c2.CatColor.Name}");
            Console.WriteLine($"Cat 1 age = {Cat.globalStartTime - c2.BirthTime}");

            var c3 = new Cat() { CatColor = Color.Orange, BirthTime = new DateTime(2022, 05, 01) };
            Console.WriteLine($"Cat 3 birth time = {c3.BirthTime}");
            Console.WriteLine($"Cat 3 color = {c3.CatColor.Name}");
            Console.WriteLine($"Cat 1 age = { Cat.globalStartTime - c3.BirthTime}");
        }
    }
}
```
![image](https://user-images.githubusercontent.com/115066329/236631216-5c10e4cf-3c11-4d6e-bbdd-676fe2c62997.png)


## 9.1.5 Object initializer

ในบางกรณี เราไม่สามารถสร้าง constructor หลายๆ ตัวเพื่อที่จะรับค่า parameters ที่แตกต่างกันเข้าสู่ object

ในภาษา C# มีวิธีการกำหนดค่าเริ่มต้นให้ properties ผ่าน Object initializer

รันโปรแกรมตามตัวอย่างนี้และบันทึกผล

```cs
using System.Drawing;

namespace ConstructorExample
{
    class Cat
    { 
        public DateTime BirthTime { get; set; }
        public Color CatColor { get; set; }
        public static int catID;
        public Cat() 
        {
            BirthTime = DateTime.Now;
            CatColor = Color.Transparent;
            catID++;
        }
        public Cat(Color catColor) :this()     
        {
            CatColor = catColor;
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            var c3 = new Cat() { CatColor = Color.Orange, BirthTime = new DateTime(2023, 05, 01) };
            Console.WriteLine($"Cat 3 birth time = {c3.BirthTime}");
            Console.WriteLine($"Cat 3 color = {c3.CatColor.Name}");
        }
    }
}

```
![image](https://user-images.githubusercontent.com/115066329/236631245-2281eda1-52bf-4c9d-b259-052d284e2471.png)


### คำถาม

 1. ท่านคิดว่าวิธีการทำ constructor overloading แล้วเรียกต่อกันเป็นทอดๆ จะช่วยอำนวยความสะดวกอะไรในการเขียนโปรแกรมของท่าน
    ```
    ช่วยให้โปรแกรมทำงานได้อย่างมีประสิทธิภาพมากขึ้น
    ```
 2. เปรียบเทียบประโยชน์และข้อจำกัด ในการใช้ overloaded constructor และ Object initializer
     ```
    overloaded constructor
    ประโยชน์
    -สามารถกำหนดค่าเริ่มต้นให้กับ object ได้หลายรูปแบบ โดยสามารถกำหนดจำนวนและประเภทของ parameter ต่างกันได้ จึงสามารถสร้าง object ได้อย่างสะดวกและเหมาะสมกับการใช้งานของผู้ใช้งาน
    -ช่วยลดการเขียน code ในกรณีที่ต้องการกำหนดค่าเริ่มต้นที่แตกต่างกันขึ้นอยู่กับสถานการณ์การใช้งาน โดยไม่ต้องใช้ if-else statement หรือการเขียน method ในการกำหนดค่าเริ่มต้นแบบเฉพาะหน้า
    -ช่วยให้โค้ดมีความกระชับและเข้าใจง่ายกว่าเมื่อใช้ Object initializer
    ข้อจำกัด
    -การมีจำนวน constructor ที่มากเกินไปอาจทำให้เกิดความสับสนหรือยุ่งเหยิงในการใช้งาน
    -การสร้าง constructor ที่มี signature ที่ซับซ้อนอาจทำให้เกิดปัญหาความซับซ้อนในการเขียนโค้ด และอาจทำให้เกิดบั๊กได้ง่ายขึ้น
    
    Object initializer
    ประโยชน์
    -สามารถกำหนดค่าเริ่มต้นให้กับ object ได้โดยไม่ต้องสร้าง constructor เพิ่มเติม ทำให้เขียน code ได้สั้นและกระชับ
    -ช่วยให้ผู้ใช้งานสามารถกำหนดค่า property ได้ง่ายและสะดวก
    ข้อจำกัด
    -ไม่สามารถกำหนดค่า property ที่มี modifier เป็น private หรือ protected ได้โดยตรง โดยจะต้องเขียน getter/setter method เพื่อให้ผู้ใช้งานสามารถเข้าถึงได้
    -ไม่สามารถกำหนดค่า property ที่มีการตรวจสอบเงื่อนไขการกำหนดค่า (validation) ได้โดยตรง โดยจะต้องใช้ constructor หรือ method แบบเฉพาะหน้าเพื่อกำหนดค่าเริ่มต้น
    -ไม่สามารถกำหนดค่า property ในลำดับที่ต้องการได้ แต่จะต้องเรียงตามลำดับที่ปรากฏในคลาส
     ```
